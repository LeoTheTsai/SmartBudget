import {
  Box, Paper, Typography, Grid, Select, MenuItem, TextField, Button, Stack, Container, useMediaQuery, useTheme
} from '@mui/material'
import { useState, useMemo, useEffect } from 'react'
import SpendingDonutChart from '../components/SpendingDonutChart'
import SpendingTrendChart from '../components/SpendingTrendChart'
import { Transaction } from '../types/Transaction'

const getMonthYear = (date: Date) => `${date.getFullYear()}-${date.getMonth() + 1}`

const Analysis = () => {
  // --- 1. Interactive Filters ---
  const [category, setCategory] = useState('All')
  const [minAmount, setMinAmount] = useState('')
  const [maxAmount, setMaxAmount] = useState('')
  const [dateFrom, setDateFrom] = useState('')
  const [dateTo, setDateTo] = useState('')
  const [transactions, setTransactions] = useState<Transaction[]>([])
  const theme = useTheme()
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'))

  useEffect(() => {
    const fetchTransactions = async () => {
      try {
        const res = await fetch('http://localhost:5000/api/transactions')
        const data = await res.json()
        const today = new Date()

        const autoGenerated = data.flatMap((t: any) => {
          if (t.recurring) {
            const txDate = new Date(t.date)
            const monthsDiff = (today.getFullYear() - txDate.getFullYear()) * 12 + (today.getMonth() - txDate.getMonth())
            const instances = []
            for (let i = 1; i <= monthsDiff; i++) {
              const cloned = { ...t, date: new Date(txDate.getFullYear(), txDate.getMonth() + i, txDate.getDate()) }
              instances.push(cloned)
            }
            return [t, ...instances]
          }
          return t
        })

        setTransactions(autoGenerated)
      } catch (err) {
        console.error('Error fetching transactions:', err)
      }
    }

    fetchTransactions()
  }, [])

  // --- 2. Comparison Features ---
  const now = new Date()
  const thisMonth = `${now.getFullYear()}-${now.getMonth() + 1}`
  const lastMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1)
  const lastMonth = `${lastMonthDate.getFullYear()}-${lastMonthDate.getMonth() + 1}`

  // --- 3. Category Breakdown ---
  const categories = useMemo(
    () => Array.from(new Set(transactions.map(t => t.category))),
    [transactions]
  )
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null)

  // Filtered transactions
  const filtered = useMemo(() => {
    return transactions.filter(t => {
      const tDate = new Date(t.date)
      if (category !== 'All' && t.category !== category) return false
      if (minAmount && parseFloat(t.amount) < parseFloat(minAmount)) return false
      if (maxAmount && parseFloat(t.amount) > parseFloat(maxAmount)) return false
      if (dateFrom && tDate < new Date(dateFrom)) return false
      if (dateTo && tDate > new Date(dateTo)) return false
      return true
    })
  }, [transactions, category, minAmount, maxAmount, dateFrom, dateTo])

  // This month and last month totals
  const thisMonthTotal = useMemo(() =>
    transactions
      .filter(t => getMonthYear(new Date(t.date)) === thisMonth)
      .reduce((sum, t) => sum + parseFloat(t.amount), 0)
  , [transactions, thisMonth])

  const lastMonthTotal = useMemo(() =>
    transactions
      .filter(t => getMonthYear(new Date(t.date)) === lastMonth)
      .reduce((sum, t) => sum + parseFloat(t.amount), 0)
  , [transactions, lastMonth])

  const percentChange = lastMonthTotal === 0
    ? (thisMonthTotal === 0 ? 0 : 100)
    : ((thisMonthTotal - lastMonthTotal) / lastMonthTotal) * 100

  // Category breakdown for donut chart (using filtered transactions)
  const categoryData = useMemo(() => {
    const map: Record<string, number> = {}
    filtered.forEach(t => {
      if (!map[t.category]) map[t.category] = 0
      map[t.category] += parseFloat(t.amount)
    })
    return Object.entries(map).map(([cat, value]) => ({ category: cat, value }))
  }, [filtered])

  // Drill-down: show only transactions for selected category
  const drilldownTransactions = selectedCategory
    ? filtered.filter(t => t.category === selectedCategory)
    : filtered

  return (
    <>
    <Box sx={{ p: { xs: 1, md: 3 } }}>
      <Typography variant="h4" mb={2}>Analysis</Typography>
      {/* 1. Interactive Filters */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Typography variant="h6" mb={2}>Filters</Typography>
        <Grid container spacing={2}>
          <Grid item xs={12} sm={3}>
            <Select
              value={category}
              onChange={e => setCategory(e.target.value)}
              fullWidth
              displayEmpty
            >
              <MenuItem value="All">All Categories</MenuItem>
              {categories.map(cat => (
                <MenuItem key={cat} value={cat}>{cat}</MenuItem>
              ))}
            </Select>
          </Grid>
          <Grid item xs={6} sm={2}>
            <TextField
              label="Min Amount"
              type="number"
              value={minAmount}
              onChange={e => setMinAmount(e.target.value)}
              fullWidth
            />
          </Grid>
          <Grid item xs={6} sm={2}>
            <TextField
              label="Max Amount"
              type="number"
              value={maxAmount}
              onChange={e => setMaxAmount(e.target.value)}
              fullWidth
            />
          </Grid>
          <Grid item xs={6} sm={2}>
            <TextField
              label="From"
              type="date"
              value={dateFrom}
              onChange={e => setDateFrom(e.target.value)}
              fullWidth
              InputLabelProps={{ shrink: true }}
            />
          </Grid>
          <Grid item xs={6} sm={2}>
            <TextField
              label="To"
              type="date"
              value={dateTo}
              onChange={e => setDateTo(e.target.value)}
              fullWidth
              InputLabelProps={{ shrink: true }}
            />
          </Grid>
          <Grid item xs={12} sm={1}>
            <Button
              variant="outlined"
              color="secondary"
              onClick={() => {
                setCategory('All')
                setMinAmount('')
                setMaxAmount('')
                setDateFrom('')
                setDateTo('')
              }}
              fullWidth
            >
              Reset
            </Button>
          </Grid>
        </Grid>
      </Paper>

      {/* 2. Comparison Features */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Typography variant="h6" mb={2}>Comparison</Typography>
        <Stack direction="row" spacing={4} alignItems="center">
          <Box>
            <Typography variant="subtitle2">This Month</Typography>
            <Typography variant="h5" color="primary">${thisMonthTotal.toFixed(2)}</Typography>
          </Box>
          <Box>
            <Typography variant="subtitle2">Last Month</Typography>
            <Typography variant="h5" color="text.secondary">${lastMonthTotal.toFixed(2)}</Typography>
          </Box>
          <Box>
            <Typography variant="subtitle2">Change</Typography>
            <Typography
              variant="h5"
              color={percentChange > 0 ? 'success.main' : percentChange < 0 ? 'error.main' : 'text.secondary'}
            >
              {percentChange >= 0 ? '+' : ''}
              {percentChange.toFixed(1)}%
            </Typography>
          </Box>
        </Stack>
      </Paper>

      {/* 3. Category Breakdown */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Typography variant="h6" mb={2}>Category Breakdown</Typography>
        <SpendingDonutChart
          data={categoryData}
          onClickCategory={cat => setSelectedCategory(cat === selectedCategory ? null : cat)}
          selectedCategory={selectedCategory}
        />
        {selectedCategory && (
          <Box mt={2}>
            <Typography variant="subtitle1">
              Transactions for <b>{selectedCategory}</b>
              <Button size="small" onClick={() => setSelectedCategory(null)} sx={{ ml: 2 }}>
                Clear
              </Button>
            </Typography>
            <ul>
              {drilldownTransactions.map(t => (
                <li key={t._id || t.id}>
                  {t.date}: ${t.amount} {t.note && `- ${t.note}`}
                </li>
              ))}
            </ul>
          </Box>
        )}
      </Paper>
    </Box>
    {/* Remove the old SpendingDonutChart below if you don't want it */}
    <Container maxWidth="lg" sx={{ mt: isMobile ? 2 : 5, px: isMobile ? 1 : 3 }}>
        <Typography variant={isMobile ? "h6" : "h5"} mb={3}>Spending Analysis</Typography>
        <Grid container spacing={isMobile ? 1.5 : 3}>
          <Grid item xs={12} md={6}>
            <Paper
              elevation={3}
              sx={{
                p: isMobile ? 1.5 : 3,
                borderRadius: 3,
                overflowX: isMobile ? 'auto' : 'visible',
                minWidth: isMobile ? 320 : 'auto'
              }}
            >
              <SpendingTrendChart transactions={filtered} />
            </Paper>
          </Grid>
        </Grid>
      </Container>
    </>
  )
}

export default Analysis